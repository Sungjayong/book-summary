# 2장. 아키텍처 개요

## 2.1 네 개의 영역

- 표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역임.

- 표현 영역(UI 영역) : 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 함.
  - 예) MVC 프레임워크
  - ![image-20220619220950502](/Users/jayo/Library/Application Support/typora-user-images/image-20220619220950502.png)

- 응용 영역 : 표현 영역을 통해 사용자의 요청을 전달받는 영역.
  - 예) '주문 등록', '주문 취소', '상품 상세 조회'
  - 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임.

~~~java
public class CancelOrderService {
	@Transactional
  public void cancelOrder(String orderId) {
    Order order = findOrderById(orderId);
    if(order == null) throw new OrderNotFoundException(orderId);
    order.cancel();
  }
  ...
}
~~~

- 도메인 영역 : 도메인 모델을 구현
  - 주문 도메인 > '배송지 변경', '결제 완료' 등 핵심 로직 구현
- 인프라스트럭처 영역 : 구현 기술에 대한 것을 다룸.
  - RDBMS 영역 처리, 메시징 큐에 메시지를 전송 or 수신, 몽고 DB, 레디스와의 데이터 연동을 처리

## 2.2 계층 구조 아키텍처

- 네 영역의 아키텍처 구성
- <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220619222331900.png" alt="image-20220619222331900" style="zoom:50%;" />
- 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않음
- 물론 편리함을 위해 계층 구조를 유연하게 적용하기도 함
- 룰 엔진? 룰(로직)을 별도로 만들어 두고 프로그램에서 룰을 가져다 쓸 수 있게 해 주는 기능 제공
- 인프라스트럭처에 의존하면 '테스트 어려움'과 '기능 확장의 어려움'이라는 문제가 발생함
- 해답은? DIP

## 2.3 DIP

- 가격 할인 계산을 한다고 하자.
- <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220619225033241.png" alt="image-20220619225033241" style="zoom:50%;" />
- 고수준 모듈 : 어떤 의미 있는 단일 기능을 제공하는 모듈
- 저수준 모듈 : 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
- 위 문제점? 고수준 모듈이 저수준 모듈을 사용하면 구현 변경, 테스트의 어려움이라는 문제가 생김
- DIP에선 이를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꿈

~~~java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

// 생성자 방식으로 주입
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);

//사용할 저수준 객체 변경
RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();

// 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다.
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);
~~~

#### 2.3.1 DIP 주의사항

- 단순히 인터페이스와 구현 클래스를 분리하는 정도로만 받아들일 수 있는데, 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.

#### 2.3.2 DIP와 아키텍처

- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다.
- 아키텍처 수준에서 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존하는 구조가 된다.
- <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220708134648712.png" alt="image-20220708134648712" style="zoom:30%;" />

## 2.4 도메인 영역의 주요 구성요소

- 도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심 로직을 구현한다.

| 요소                              | 설명                                                         |
| --------------------------------- | :----------------------------------------------------------- |
| 엔티티<br />ENTITY                | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다. |
| 밸류<br />VALUE                   | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소나 구매 금액을 위한 금액과 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다. |
| 애그리거트<br />AGGREGATE         | 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티,  OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다. |
| 리포지터리<br />REPOSITORY        | 도메인 모델의 영속성을 처리. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공 |
| 도메인 서비스<br />DOMAIN SERVICE | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. |

#### 2.4.1 엔티티와 밸류

- DB 테이블의 엔티티와 도메인 모델의 엔티티는 같은 것이 아니다.

- 가장 큰 차이는 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다.

  - 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다.

    ~~~java
    public class Order {
      //주문 도메인 모델의 데이터
      private OrderNo number;
      private Orderer orderer;
      private ShippingInfo shippingInfo;
     	...
       
      // 도메인 모델 엔티티는 도메인 기능도 함께 제공
      public void changeShippingInfo(ShippingInfo newShippingInfo) {
        ...
      }
    }
    ~~~

  - 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다.

- 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.

  - Orderer는 밸류 타입으로 주문자 이름과 이메일 데이터를 포함할 수 있다.

#### 2.4.2 애그리거트

- 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현한다.

- 엔티티와 밸류 개수가 많아질수록 모델은 점점 더 복잡해진다.

- 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 바로 애그리거트.

- 애그리거트는 관련 객체를 하나로 묶은 군집

  - 주문이라는 도메인 개념은 '주문', '배송지 정보', '주문자', '주문 목록', '총 결제 금액'의 하위 모델로 구성
  - 이 하위 개념을 표현한 모델을 하나로 묶어서 '주문'이라는 상위 개념으로 표현할 수 있다.

- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다.

- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다 => 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 도움!

  - 애그리거트 루트인 Order는 주문 도메인 로직에 맞게 애그리거트 상태를 관리한다.

  <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220708154217727.png" style="zoom:50%;" /> 

  - 주문 애그리거트는 Order를 통하지 않고 ShippingInfo를 변경할 수 있는 방법을 제공하지 않는다.

#### 2.4.3 리포지터리

- 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야 한다.
- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 응용 서비스는 의존 주입과 같은 방식을 사용해서 실제 리포지터리 구현 객체에 접근한다.
  - 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
  - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받는다.

## 2.5 요청 처리 흐름

- 사용자가 애플리케이션에 기능 실행을 요청하면 그 요청을 처음 받는 영역은 표현 영역이다.
- 응용 서비스는 도메인 모델을 이용해서 기능을 구현
- '예매하기'나 '예매 취소'와 같은 기능을 제공하는 응용 서비스는 도메인의 상태를 변경하므로 변경 상태가 물리 저장소에 올바르게 반영되도록 트랜잭션을 관리해야 한다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원
- 영속성 처리를 위해 JPA를 사용할 경우 JPA 전용 애너테이션을 도메인 모델 클래스에 사용하는 것이 XML 매핑 설정을 이용하는 것보다 편리하다.

~~~java
// 구현의 편리함을 위해 인프라스트럭처에 대한 의존을 일부 도메인에 넣은 코드.
// JPA의 @Table 애너테이션을 이용해서 엔티티를 저장할 테이블 이름을 지정했다.
// XML 설정을 사용하는 것보다 편리하게 테이블 이름을 지정할 수 있다.
@Entity
@Table(name = "TBL_ORDER")
public class Order {
  ...
}
~~~

## 2.7 모듈 구성

- 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.
-  <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220708163452168.png" alt="image-20220708163452168" style="zoom:60%;" />

- <img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220708163525689.png" alt="image-20220708163525689" style="zoom:60%;" />

- 애그리거트, 모델, 리포지터리는 같은 패키지에 위치시킨다.
  - Order, OrderLine, Orderer, OrderRepository => com.myshop.order.domain
- 모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다.
- 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다.(10~15개 미만)







