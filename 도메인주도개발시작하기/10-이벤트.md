# 10장. 이벤트

## 10.1 시스템 간 강결합 문제

- 외부 결제 시스템이 제공하는 환불 서비스를 호출할 때의 문제
  - 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할지 애매함.
  - 성능. 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어짐.
- 이러한 문제들의 이유?
  - 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 강결합(high coupling) 때문.
  - 이를 없애는 방법이 바로 (비동기) 이벤트

## 10.2 이벤트 개요

- 이벤트? 과거에 벌어진 어떤 것
- 이벤트가 발생한다는 것 -> 상태가 변경됐다는 것을 의미

### 10.2.1 이벤트 관련 구성요소

- 도메인 모델에 이벤트를 도입하는 방법

- 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들어(구독자)를 구현해야 함

  <img src="/Users/seongjayong/Library/Application Support/typora-user-images/image-20220723202147147.png" alt="image-20220723202147147" style="zoom:50%;" />

- 이벤트 생성 주체 : 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- 이벤트 핸들러 : 이벤트 생성 주체가 발생한 이벤트에 반응
- 이벤트 디스패처 : 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 것

### 10.2.2 이벤트의 구성

- 이벤트는 발생한 이벤트에 대한 정보를 담는다.

  - 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현
  - 이벤트 발생 시간
  - 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

  ~~~java
  public class ShippingInfoChangedEvent {
    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;
  }
  ~~~

  - class 명을 보면 과거 시제를 사용했는데, 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트명에는 과거 시제를 사용함.

  ~~~java
  public class ShippingInfoChangedHandler {
    @EventListener(ShippingInfoChangedEvent.class)
    public void handle(ShippingInfoChangedEvent evt) {
      shippingInfoSynchronizer.sync(
      				evt.getOrderNumber()
      				evt.getNewShippingInfo()
      );
    }
  }
  ~~~

  ### 10.2.3 이벤트 용도

  - 이벤트는 크게 두 가지 용도로 쓰인다.

    1. 트리거
       - 도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
       - 예> 주문 취소 이벤트, 예매 결과를 SMS로 통지

    2. 서로 다른 시스템 간의 데이터 동기화
       - 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다.

### 10.2.4 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있음
- 기능 확장도 용이
  - 구매 취소 시 환불 이메일을 보내고 싶다? 이메일 발송을 처리하는 핸들러를 구현하면 됨!

## 10.3 이벤트, 핸들러, 디스패처 구현

- 이벤트 클래스 : 이벤트를 표현한다.
- 디스패처 : 스프링이 제공하는 ApplicationEventPublisher를 이용
- Events : 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher를 사용
- 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용

### 10.3.1 이벤트 클래스

- 이벤트 클래스의 이름을 결정할 때에는 과거 시제를 사용해야 한다는 점만 유의하자.

- 접미사로 Event 사용!

- 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함해야 함.

- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있다.

  ~~~java
  package com.myshop.common.event;
  
  public abstract class Event {
    private long timestamp;
    
    public Event() {
      this.timestamp = System.currentTimeMillis();
    }
    
    public long getTimestamp() {
      return timestamp;
    }
  }
  ~~~

### 10.3.2 Events 클래스와 ApplicationEventPublisher

- 이벤트 발생과 출판을 위해 사용

~~~java
package com.myshop.common.event;

public class Events {
  private static ApplicationEventPublisher publisher;
  
  public static void raise(Object Event) {
    if(publisher != null) {
      publisher.publishEvent(event);
    }
  }
}

~~~

- raise() : 이벤트 발생

### 10.3.3 이벤트 발생과 이벤트 핸들러

~~~java
Events.raise(new OrderCanceledEvent(number.getNumber()));
~~~

~~~java
@EventListener(OrderCanceledEvent.class)
public void handle(OrderCanceledEvent event) {
  refundService.refund(event.getOrderNumber());
}
~~~

### 10.3.4 흐름 정리

<img src="/Users/seongjayong/Library/Application Support/typora-user-images/image-20220723205200901.png" alt="image-20220723205200901" style="zoom:50%;" />

1. 도메인 기능 실행
2. 도메인 기능은 Events.raise()를 이용해서 이벤트 발생시킴
3. Events.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트를 출판
4. ApplicationEventPublisher는 @EventListener(이벤트타입.class) 애너테이션이 붙은 메서드를 찾아 실행

## 10.4 동기 이벤트 처리 문제

- 외부 시스템과의 연동을 동기로 처리할 때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계하는 것







