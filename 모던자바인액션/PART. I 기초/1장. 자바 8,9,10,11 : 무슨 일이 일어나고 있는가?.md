1장. 자바 8,9,10,11 / 무슨 일이 일어나고 있는가?

## 이 장의 내용

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 기능 소개

## 1.1 역사의 흐름은 무엇인가?

- 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.

~~~java
// 고전 코드
Collections.sort(inventory, new Comparator<Apple>() {
  public inst compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
});

// 자바 8 방식
inventory.sort(comparing(Apple::getWeight));
~~~

- 자바는 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.
  - 스트림 API
  - 메서드에 코드를 전달하는 기법
  - 인터페이스의 디폴트 메서드
- 데이터베이스 질의 언어에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 **스트림**이라는 새로운 API를 제공한다.
  - 비용이 비싼 synchronized 키워드를 사용하지 않아도 됨
- 메서드에 코드를 전달하는 기법을 이용하면 새롭고 간결한 방식으로 동작 파라미터화(behavior parameterization)를 구현할 수 있다.

## 1.2 왜 아직도 자바는 변화하는가?

- 새로운 언어가 등장하면 진화하지 않은 기존 언어는 사장되었다.
- 완벽한 언어는 현실적으로 존재하지 않으며 모든 언어가 장단점을 갖고 있다.

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

- 자바는 처음부터 스레드와 락을 이용한 소소한 동시성을 지원
- 코드를 JVM 바이트 코드로 컴파일하는 특징 -> 인터넷 애플릿 프로그램의 주요 언어가 되었다.
  - 애플릿? 인터넷 등을 통해 원격 자원에 접근하여 프로그램을 실행시켜 결과를 얻을 수 있는 프로그램
- 자바8에 추가된 기능은 자바에 없던 완전히 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다.

### 1.2.2 스트림 처리

- stream processing. 
- 스트림? 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
- 예> 파일의 단어를 소문자로 바꾼 다음에 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램
- 자바 8에는 java.util.stream 패키지에 스트림 API가 추가되었다.
- 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것.
- 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다!

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

- 코드 일부를 API로 전달하는 기능
- 2013UK0001, 2016US0002 등의 형식을 갖는 송장 ID가 있다고 하자.
  - 이를 sort? compareUsingCustomerId 메서드를 구현해야 한다

### 1.2.4 병렬성과 공유 가변 데이터

- 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들기 위해 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다. -> 순수 함수, 부작용 없는 함수(side-effect-free), 상태 없는 함수(stateless)
- 공유되지 않는 가변 데이터, 메서드, 함수 코드를 다른 메서드로 전달하는 두가지 기능은 함수형 프로그래밍 패러다임의 핵심적인 사항.

### 1.2.5 자바가 진화해야 하는 이유

- 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다는 것

## 1.3 자바 함수

- 자바 8에서는 함수를 새로운 값의 형식으로 추가했다.
- 프로그래밍 언어의 핵심은 값을 바꾸는 것
- 자바 프로그램에서 조작할 수 있는 값?
  - 42(int 형식), 3.14(double 형식), 객체(new 또는 펙토리 메서드 또는 라이브러리 함수), 
  - 객체 참조( new Integer(1111), new HashMap<Integer, String>(100) )
- 프로그래밍 언어에서는 이 값을 일급(first-class) 값이라고 부른다.
- 자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스, ...)가 값의 구조를 표현하는 데 도움이 될 수 있다.
- 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다.
- 위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 시민에 해당한다.
- 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다.
- 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다.

### 1.3.1 메서드와 람다를 일급 시민으로

- 스칼라와 그루비 같은 언어에서 메서드를 일급값으로 사용하면 프로그래머가 활용할 수 있는 도구가 다양해지면서 프로그래밍이 수월해진다는 사실을 이미 실험을 통해 확인했다.

- 메서드 참조(method refernece, ::)

  ~~~java
  File[] hiddenFiles = new File(".").listFiles(File::isHidden);
  ~~~

  - ::('이 메서드를 값으로 사용하라'는 의미)
  - 이 때 메서드가 아닌 함수라는 용어를 사용함.
  - 기존에 비해 문제 자체를 더 직접적으로 설명한다는 점이 자바 8 코드의 장점!

#### 람다 : 익명 함수

- 메서드를 일급값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다.
  - 클래스를 만든 다음에 클래스 내부에 add1이라는 메서드를 정의해서 Utils::add1을 만들 수 있지만 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.

- 특정 항목을 선택해서 반환하는 동작 -> 필터(filter)

  ~~~java
  static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
      if(p.test(apple)) {
        result.add(apple);
      }
    }
    return result;
  }
  
  filterApples(inventory, Apple::isGreenApple);
  filterApples(inventory, Apple::isHeavyApple);
  ~~~

- 프레디케이트(predicate)란?

  - 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다.

### 1.3.3 메서드 전달에서 람다로

- 메서드를 값으로 전달하는 것은 분명 유용한 기능이다. 하지만 한두 번만 사용할껀데 이걸 매번 정의해야할까?

- 다음처럼 라이브러리 메서드 filter를 이용하면 filterApples 메서드를 구현할 필요가 없다.

  ~~~Java
  filter(inventory, (Apple a) -> a.getWeight() > 150);
  ~~~

- 하지만 병렬성이라는 중요성 때문에 이와 같은 설계를 포기하고, 대신 스트림 API를 제공한다.( + 추가로 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공한다)

## 1.4 스트림

- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다.

~~~java
Map<Currency, List<Transaction>> transactionsByCurrencies =
  	transactions.stream()
  			.filter((Transaction t) -> t.getPrice() > 1000)
  			.collect(groupingBy(Transaction::getCurrency));
~~~

- 외부 반복(external iteration) : for-each 루프를 이용해서 각 요소를 반복하면서 작업 수행
- 내부 반복(internal iteration) : 스트림 API를 이용한 루프 수
- 멀티코어 컴퓨터
  - 전통적인 자바 프로그램은 많은 CPU 중 단 하나만 사용하면서 나머지 CPU를 낭비시키는 것이 문제였음
  - 많은 회사에서 컴퓨팅 클러스터(고속 네트워크로 서로 연결된 컴퓨터)를 이용해서 대량의 데이터를 효과적으로 처리.
  - 자바 8에서는 이런 컴퓨터를 더 잘 활용할 수 있는 새로운 프로그래밍 스타일을 제공

### 1.4.1 멀티스레딩은 어렵다

- 멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다.
- 스레드를 잘 제어하지 못하면 원치 않는 방식으로 데이터가 바뀔 수 있다.
- 멀티스레딩 모델은 순차적인 모델보다 다루기가 어렵다.

- 자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다.

<img src="/Users/seongjayong/Library/Application Support/typora-user-images/image-20220810162321260.png" alt="image-20220810162321260" style="zoom:50%;" />

1. 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청 -> 포킹 단계(forking step)
2. 각각의 CPU는 자신이 맡은 절반의 리스트를 처리
3. 하나의 CPU가 두 결과를 정리

- 컬렉션 -> 어떻게 데이터를 저장하고 접근할지에 중점

- 스트림 -> 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점

- **스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심!**

- 이상하게 생각될 수 있지만, 컬렉션을 필터링하는 가장 빠른 방법은 컬렉션을 스트림으로 바꾸고, 병렬로 처리한 다음에, 리스트로 다시 복원하는 것!

- 스트림과 람다 표현식을 이용하면 '병렬성을 공짜로' 얻을 수 있다!

  ~~~java
  inventory.stream().filter((Apple a) -> a.getWeight() > 150)
  ~~~

- 자바의 병렬성과 공유되지 않은 가변 상태

  - 자바의 병렬성은 어렵고 synchronized는 쉽게 에러를 일으킨다 -> 어떤 요술방망이를 자바 8은 제공해줄까?
    1. 라이브러리에서 분할을 처리. 즉, 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할함.
    2. 상호작용을 하지 않는다면 가변 공유 객체를 통해 공짜로 병렬성을 누릴 수 있다.
  - 함수형 = '함수를 일급값으로 사용한다' = (부가적으로) '프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않는다.'

## 1.5 디폴트 메서드와 자바 모듈

- 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.

~~~java
List<Apple> heavyApples1 =
inventory.stream().filter((Apple a) -> a.getWeight() > 150)
  								.collect(toList());
List<Apple> heavyApples2 =
inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
  								.collect(toList());
~~~

- 자바 8 이전에는 List<T>가 stream이나 parallelStream 메서드를 지원하지 않는게 문제였다.

- 직접 인터페이스를 만들 수 있지만, 이는 개발자에게 너무 큰 고통이다.

- 어떻게 기존의 구현을 고치지 않고도 이미 공개된 인터페이스를 변경할 수 있을까?

  - 결정적으로 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다.
  - 메서드 본문은 클래스 구현이 아니라 인터페이스의 일부로 포함된다.

- 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

- 인터페이스 규격명세에 default라는 새로운 키워드를 지원한다.

- 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다.

  ~~~java
  default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
  }
  ~~~

- 그렇다면, 하나의 클래스에서 여러 인터페이스를 구현할 수 있을텐데, 이는 결국 다중 상속이 허용된다는 것일까?
  - 엄밀히 다중 상속은 아니지만 어느정도는 그렇다라고 말할 수 있다.
  - 다이아몬드 상속 문제를 피할 수 있는 방법을 9장에서 설명할 것이다.

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

- 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공한다.
  - Optional<T> : 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다.
- 패턴 매칭 기법
  - 존재는 하지만, 자바 8은 패턴 매칭을 완벽하게 지원하지는 않음.
  - 스칼라를 사용하는 하나의 장점이 이런게 아닐까.

## 1.7 마치며

- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 된다.
- 기존의 자바 프로그래밍 기법(1.8 이전)으로는 멀티코어 프로세서를 온전히 활용하기 어렵다.
- 함수는 일급값이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억하자.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다.

















