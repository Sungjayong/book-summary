# 1장. 모놀리식 지옥에서 벗어나라

> 모놀리식 애플리케이션이 모놀리식 아키텍처라는 옷이 맞지 않을 정도로 커졌을 때 나타나는 모놀리식 지옥의 징후와 이 지옥을 마이크로서비스 아키텍처를 도입해서 탈출하는 방안을 모색합니다.

- What is Monolithic Architecture?
  - "단일체의"
  - 하나의 서비스 또는 애플리케이션이 하나의 거대한 아키텍처를 가질 때, 이를 칭함.
    - JAVA의 경우 war 파일, GO의 경우 실행 파일 하나만 있는 아키텍처
  - 내부 요소간의 의존성이 강하다는 특징이 있음.

- 모놀리식 지옥이 도래할 조짐과 마이크로서비스 아키텍처를 도입하여 이 지옥에서 벗어나는 법.
- 마이크로 서비스 아키텍처의 주요 특징과 장단점
- 크고 복잡한 애플리케이션을 데브옵스 스타일로 개발하는 방법
- 마이크로서비스 아키텍처 패턴 언어를 사용하는 이유



## 1.1 서서히 모놀리식 지옥에 빠져들다.

- FTGO 회사에 다니는 메리는 소프트웨어 개발 프로세스를 개선하고자 한다.
- 애자일 방법론만으로는 힘든 문제들이 많았고, 비즈니스 목표 달성이 쉽지 않은데,
- 마이크로서비스 아키텍처를 어떤 식으로 도입해야는지를 깊게 생각해보자.

#### 1.1.1 FTGO 애플리케이션 아키텍처

<img src="/Users/jayo/Library/Application Support/typora-user-images/image-20220203135937008.png" alt="image-20220203135937008" style="zoom:50%;" />

- Business Logic은 각자가 도메인 객체 컬렉션인 모듈(예: 주문 관리, 배달 관리, 과금, 지불)로 구성되며, 외부 시스템과 연계하는 어댑터가 여럿 달려 있음.
- REST API, 웹 UI 어댑터 등 비즈니스 요청을 호출하여 처리하는 인바운드 어댑터가 있고,
- DB 접속, 클라우드 서비스 호출을 위한 아웃바운드 어댑터가 있음.
- "논리적으로는 모듈화한 아키텍처임에도 애플리케이션은 WAR 파일 하나로 패키징함."
- 물론 과거에는 이러한 선택이 올바른 선택이었음.

#### 1.1.2 모놀리식 아키텍처의 장점

1. 개발이 간단하다
2. 애플리케이션을 쉽게 변경할 수 있다.
3. 테스트하기 쉽다.
4. 배포하기 쉽다 : 톰캣 설치 경로에 WAR 파일을 복사하면 끝.
5. 확장하기 쉽다 : load balancer 뒷면에 애플리케이션 인스턴스를 여러 개 실행함.

#### 1.1.3 모놀리식 지옥의 실상

- 하지만 이에는 한계가 있다. 
- 규모가 커질수록(FTGO처럼) 스프린트를 할 때마다 추가 구현할 스토리가 늘어났고 그만큼 코드베이스와 관리 오버헤드 역시 증가함.

1. 너무 복잡해서 개발자가 주눅들다.

![image-20220203141847898](/Users/jayo/Library/Application Support/typora-user-images/image-20220203141847898.png)

- 너무 복잡해지면서, 여느 개발자가 완전히 이해할 수 없을 정도록 내용이 방대해 짐.

2. 개발이 더디다.

   - 복잡도와 별개로 개발자의 일상적인 개발 업무도 더디게 진행됨.

   - 개발자 IDE 실행속도도 느려지고, 빌드 시간도 오래 걸리게 됨.

3. 커밋부터 배포에 이르는 길고 험난한 여정
   - 고친 내용을 프로덕션에 배포하는 일이 아주 길고 고통스러움.
   - 메리는 SaaS 애플리케이션의 최근 트렌드가 지속적 배포(
     continuous deployment)라는 사실에 주목하는데 이는 평일 업무 시간 중에 몇 번이고 원하는 횟수만큼 변경분을 배포하게 해준다는 기술. => 이를 모놀리식 앱인 FTGO에 도입하는 것은 사실상 불가능함.
   - 테스트 시간 역시 많이 걸리게 됨.

4. 확장하기 어렵다.
   - 모듈마다 리소스 요건이 서로 맞지 않아 확장하기 어려움.
   - 예로, 데이터 용량이 큰 음식점 데이터는 인-메모리 DB 형태로 저장하는데, 이런 DB는 메모리 칩이 많이 장착된 서버에 배포하는 것이 좋지만, 이미지 처리 모듈은 CPU를 집중 소모하므로 CPU 코어 수가 많은 서버에 배포하는 것이 최적임. => 리소스 요건이 상이함...

5. 모놀리스는 확실하게 전달하기 어렵다.
   - 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션 인스턴스가 내려가는 일도 있음.

6. 갈수록 한물간 기술 스택에 발목이 붙잡힌다.

   

## 1.2 이 책의 대상 독자

다음 항목들은 잘 알고 있도록 하자.

- 3계층 아키텍처
  - 어떤 플랫폼을 3계층으로 나누어 별도의 논리적/물리적인 장치에 구축 및 운영하는 형태를 의미.
  - 프레젠테이션 계층 : 사용자가 직접 마주하게되는 계층. UI 지원 및 프론트엔드
  - 에플리케이션 계층 : 규칙을 바탕으로 처리하고 가공. 동적인 데이터를 제공하는 비즈니스 로직 계층, 또는 트랜잭션 계층이라고 함. 미들웨어 또는 백엔드.
  - 데이터 계층 : 데이터베이스와 데이터베이스에 접근하여 데이터를 읽거나 쓰는 것을 관리하는 것. DBMS이며, 백엔드.
  - ![image-20220203143818303](/Users/jayo/Library/Application Support/typora-user-images/image-20220203143818303.png)
- 웹 애플리케이션 설계

- 객체 지향 설계를 응용한 비즈니스 로직 개발

- RDBMS 사용법: SQL과 ACID 트랜잭션

  - ACID : DB 트랜잭션들이 안정적으로 수행된다는 것을 보장하기 위한 성질을 가리키는 약어.
  - 원자성(Atomicity) : 모두 수행되거나, 모두 실행되지 않음을 보장하는 것.
  - 일관성(Consistency) : 트랜잭션 실행 완료 후 언제나 일관성 있는 DB 상태로 유지하는 것.
  - 고립성(Isolation) : 다른 트랜잭션 연산 작업이 끼어들지 못하게 보장하는 것.
  - 지속성(Durability) : 시스템 장애 시에도 해당 트랜잭션의 커밋은 보장되어야 한다는 속성.

- 메시지 브로커와 REST API를 활용한 IPC

  - 메시지 브로커 : Publisher(송신자)로부터 전달받은 메시지를 Subscriber(수신자)로 전달해주는 중간 역할이며, 응용 소프트웨어 간에 메시지를 교환할 수 있게 함. 이 때 메시지가 적재되는 공간을 Message Queue라 하며, 메시지의 그룹을 Topic(토픽)이라 칭함.

- 인증/인가 등 보안 개념

- 스프링 프레임워크

  

## 1.3 이 책의 학습 내용

배우는 것

- 마이크로서비스의 주요 특성과 장단점, 사용 시점
- 분산 데이터 관리 패턴
- 효과적인 마이크로서비스 테스트 전략
- 마이크로서비스 배포 옵션
- 모놀리식 아키텍처를 마이크로서비스 아키텍처로 리팩터링하는 전략



## 1.4 마이크로서비스 아키텍처가 답이다.

- 메리는 FTGO 애플리케이션을 마이크로서비스 아키텍처로 전환하기로 결심함!
- 마이크로서비스란 무엇일까? 과거 넷플릭스에 근무했던 Adrian Cockeroft는 경계 컨텍스트(bounded context)가 있는, 느슨하게 결합된 엘리먼트(element)로 구성된 서비스 지향 아키텍처라고 정의함.

#### 1.4.1 확장 큐브와 마이크로서비스

![image-20220203144958348](/Users/jayo/Library/Application Support/typora-user-images/image-20220203144958348.png)

- X축 확장 : 다중 인스턴스에 고루 요청 분산
  - load balancer 뒷면에 애플리케이션 인스턴스(가상 컴퓨팅 환경, 아마 Amazon EC2?)를 N개 띄워 놓고 요청을 인스턴스에 고루 분배함.

- Z축 확장 : 요청 속성별 라우팅
  - 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법.
  - 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단.

- Y축 확장 : 기능에 따라 애플리케이션을 서비스로 분해
  - 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것. (주문, 고객, 리뷰 서비스...)
- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일. 크기가 아닌, 각 서비스가 집중된/응집된 책임을 맡고 있다는 사실.

#### 1.4.2 마이크로서비스는 모듈성을 갖고 있다.

- 모듈성은 크고 복잡한 애플리케이션을 개발할 때 꼭 필요한 특성.
- 마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용함.
- 각 서비스는 다른 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 들어올 수 없음.

#### 1.4.3 서비스마다 DB가 따로 있다.

- 마이크로서비스는 서로 느슨하게 결합되어 있고 오직 API를 통해서만 통신함.
- 이러한 서비스는 각각 자체 DB를 가지는데, 주문 서비스는 ORDERS 테이블이 있는 DB를, 고객 서비스는 CUSTOMERS 테이블이 있는 DB를 각자 소유함.
- 런타임에 서비스가 완전히 분리 되면서 다른 서비스가 DB 락을 획득해 내 서비스를 블로킹하는 일이 일어나지 않게 됨!

#### 1.4.4 FTGO 마이크로서비스 아키텍처

- 서비스는 총 5가지.
  - 주문 서비스, 배달 서비스, 음식점 서비스, 주방 서비스, 회계 서비스

![image-20220203151157759](/Users/jayo/Library/Application Support/typora-user-images/image-20220203151157759.png)

- 각 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있고, 개발자가 타 서비스의 API를 위회하거나 그 내부 요소에 직접 접근할 수 없기 때문에 모듈성 유지 차원에서도 적합한 아키텍처.

 #### 1.4.5 마이크로서비스 아키텍처와 SOA

- 마이크로서비스는 SOA(Service Oriented Architecture, 서비스 지향 아키텍처)와 별반 다를 것이 없음.

- 하지만 좀 더 깊이 들어가면 근본적인 차이점이 있다. => 일단 크게 안중요할듯해서 여기서 끝낸당

  

## 1.5 마이크로서비스 아키텍처의 장단점

#### 1.5.1 마이크로서비스 아키텍처의 장점

1. 크고 복잡한 애플리케이션을 지속적으로 전달/배포 할 수 있다.
   - 테스트성 : 지속적 전달/배포를 위해 자동화 테스트가 꼭 필요한데, 상대적으로 크기가 작아 자동화 테스트를 작성하기 쉽고 더 빨리 실행되며, 애플리케이션 버그도 적은 편.
   - 배포성 : 마이크로서비스는 독립적으로 배포할 수 있어서 다른 개발자와 협의할 필요가 없음.
   - 자율성, 느슨한 결합 : 팀별로 하나 이상의 서비스를 개발/배포하는 업무만 담당 가능.
2. 서비스 규모가 작아 관리하기 쉬움.
3. 서비스를 독립적으로 배포/확장할 수 있음.
4. 마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움직임.
5. 결함 격리가 잘 된다.
6. 새로운 기술을 실험하고 도입하기 용이.

#### 1.5.2 마이크로서비스 아키텍처의 단점

1. 딱 맞는 서비스를 찾기가 쉽지 않다.
   - 시스템을 잘못 분해할 경우, 더 최악의 결과가 만들어진다.
2. 분산 시스템은 너무 복잡해서 개발, 테스트, 배포가 어렵다.
   - 서비스마다 DB가 따로 있기 때문에 다중 DB에 접속하여 조회하고 트랜잭션을 구현하는 일이 어려움. => 사가라는 기술로 서비스 간 데이터 일관성을 유지(4장)
   - 데이터 조회를 위해 API를 조합하거나 CQRS 뷰로 쿼리함.
   - 운영 복잡도 역시 가중시킴. 종류가 다른 서비스가 여러 인스턴스로 떠 있으니 프로덕션에서 관리해야 할 가동부가 더 늘어나기 때문인데, 여러 기술(넷플릭스 스핀네이커 같은 자동화 배포 툴, 도커 스웜, 쿠버네티스 등)을 응용하여 플랫폼을 고도로 자동화해야 함.
3. 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야 한다.
4. 마이크로서비스 아키텍처 도입 시점을 결정하기가 어렵다.
   - 복잡성을 다루는 문제가 중요해지는 시점에 애플리케이션을 여러 마이크로서비스로 기능 분해하는 것이 바람직함.
   - 일반 소비자를 상대하는 웹 애플리케이션이나 SaaS처럼 복잡한 애플리케이션은 대개 마이크로서비스 아키텍처가 잘 맞음.



## 1.6 마이크로서비스 아키텍처 패턴 언어

- 다양한 아키텍처와 설계 옵션을 기술하고 더 나은 결정을 내리는 좋은 방법은 패턴 언어를 사용하는 것.
- 패턴 언어가 필요한 이유를 알아보자.

#### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다

- 모든 기술은 일장일단이 있기에 어떤 기술을 택하더라도 가트너 하이프 사이클의 전철을 밟게 됨.

#### 1.6.2 패턴 및 패턴 언어

- 패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법.
- 상용 패턴의 구조는 다음 세 부분으로 구성됨.

1. 강제 조항(force): 문제 해결을 위해 반드시 처리해야 할 이슈
   - 주어진 맥락에서 문제를 해결하고자 할 때 반드시 처리해야 할 강제 조항.
2. 결과 맥락(resulting context) : 패턴 적용 결과
   - 패턴을 적용한 결과를 다음 세 부분으로 기술하는 영역
   - 장점, 단점, 이슈
3. 연관 패턴(related patterns) : 다섯 가지 관계 유형
   - 한 패턴과 다른 패턴의 관계를 기술하는 영역
     - 선행자(predecessor) : 이 패턴을 필요하게 만든 선행 패턴.
     - 후행자(successor) : 이 패턴으로 야기된 이슈를 해결하는 패턴.
     - 대안(alternative) : 이 패턴의 대체 솔루션을 제공하는 패턴.
     - 일반화(generalization) : 문제를 해결하는 일반적인 솔루션에 해당하는 패턴.
     - 세분화(specialization) : 특정 패턴을 더 세부적으로 나타낸 형태.

- 이렇게 여러 패턴을 연관지어 패턴 언어라는 포맷으로 도출하고, 이 패턴 언어의 패턴을 사용하여 특정 영역의 문제를 해결하는 것.

#### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요

- 마이크로서비스 아키텍처 패턴 언어는 전체 애플리케이션을 마이크로서비스 아키텍처로 구성할 때 유용한 패턴의 모음집.

![image-20220203172058456](/Users/jayo/Library/Application Support/typora-user-images/image-20220203172058456.png)

- 인프라 패턴 : 주로 개발 영역 밖의 인프라 문제를 해결
- 애플리케이션 인프라 : 개발에도 영향을 미치는 인프라 문제를 해결
- 애플리케이션 패턴 : 개발자가 맞닥뜨리는 문제를 해결

- 주요 패턴 그룹
  - 애플리케이션을 여러 서비

## 1.7 마이크로서비스 너머: 프로세스와 조직

## 1.8 마치며







