# 3장. 프로세스 간 통신
- IPC : 프로세스 간 통신. 프로세스들끼리 서로 데이터를 주고받는 행위 또는 그에 대한 방법
- 모놀리식 아키텍처는 IPC를 크게 신경 쓸 필요가 없음.
- But, 마이크로서비스 아키텍처는 여러 개의 서비스로 구성되기에, 서비스는 대부분 요청 처리를 위해 상호 작용함. => 여러 머신에서 실행되는 프로세스 형태이기에!
- IPC는 REST가 대세지만, 메시징을 사용하기도 함.
## 3.1 마이크로서비스 아키텍처 IPC 개요
- IPC의 종류
  - HTTP 기반 REST
  - 동기 요청/응답 기반 통신 메커니즘인 gRPC
  - AMQP, STOMP 등 비동기 메시지 기반 통신 메커니즘
### 3.1.1 상호 작용 스타일
- 클라이언트/서비스 상호 작용 스타일
  1. 일대일/일대다 여부
  2. 동기/비동기 여부
    - 동기 : 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 할 수 있음.
    - 비동기 : 클라이언트가 블로킹하지 않음. 응답은 즉시 전송되지 않아도 됨.
  - 일대일 상호작용
   - 요청/응답
   - 비동기 요청/응답
   - 단방향 알림
  - 일대다 상호작용
   - 발행/구독(pub/sub) : 클라이언트는 알림 메시지를 발행하고, 여기에 관심있는 0개 이상의 서비스가 메시지를 소비. 
   - 발행/비동기 응답
### 3.1.2 마이크로서비스 API 정의
- 어떤 IPC를 선택하든, 서비스 API를 IDL(Interface Definition Language)로 정확하게 정의해야 한다!
- 선설계 후 구현 방식으로 진행하면 client needs에 좀 더 부합한 서비스를 구축할 수 있다
### 3.1.3 API 발전시키기
- 마이크로서비스 애플리케이션은 서비스 API를 변경하기가 무척 어려움.
- 이런 문제를 해결하기에 전략을 잘 세워야 함.
#### 시맨틱 버저닝(Semantic Veersioning)
- 시맨틱 버저닝 : 소프트웨어의 버전 변경 규칙에 대한 제안.
- 분산 시스템의 API 버저닝에 사용 가능.
- API를 올바르게 버저닝해서 일정한 규칙에 맞게 발전시키는 것이 중요함.
#### 하위 호환되는 소규모 변경
- 견고성(Robustness) 원칙 : 당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라.
### 3.1.4 메시지 포맷
- IPC의 핵심은 메시지 교환이다.
- 텍스트 메시지 포맷 : JSON, XML 등
- 이진 메시지 포맷 : 프로토콜 버퍼, 아브로 => 메시지 구조 정의에 필요한 타입 ID을 제공.

## 3.2 동기 RPI 패턴 응용 통신
- RPI(Remote Procedure Invocation, 원격 프로시저 호출) : 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC
### 3.2.1 동기 RPI 패턴: REST
- REST는 HTTP 동사를 사용해서 URL로 참조되는 리소스를 가공
#### REST API
- REST API에도 IDL이 필요하다는 공감대가 확산되며 스웨거를 통한 오픈 API 명세가 널리 보급됨.
#### 요청 한 번으로 많은 리소스를 가져오기 어렵다.
- 특정 주문과 주문한 소비자를 한 번에 가져오는 방법?
  - GET /orders/order-id-1345?expand=consumer => 복잡함
- 이에 GraphQL이나 넷플릭스 팔코 등 대체 API 기술이 각광받기 시작.
- GraphQL : 클라이언트는 필요한 데이터의 구조를 지정할 수 있으며, 서버는 정확히 동일한 구조로 데이터를 반환
#### REST의 장단점
- 단순하고 익숙하다.
- HTTP가 방화벽 친화적임.
- 중간 브로커가 필요하지 않아 시스템 아키텍처가 단순함.

- 요청/응답 스타일 통신만 지원
- 요청 한 번에 여러 리소스를 가져오기 어려움.

### 3.2.2 동기 RPI 패턴: gRPC
- gRPC : 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크이며 이진 메시지 기반의 프로토콜 => 서비스를 API 우선 방식으로 설계할 수밖에 없음!
- gRPC API는 하나 이상의 서비스와 요청/응답 메시지 데피니션(definition, 정의한 코드)으로 구성됨
- 단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원! => 메시지 스트림 응답 가능
'''
  service OrderService {
    rpc createOrder(createOrderRequest) returns (CreateOrderReply) {}
    rpc cancelOrder(cancelOrderRequest) returns (CancelOrderReply) {}
    rpc reviseOrder(reviseOrderREquest) returns (ReviseOrderReply) {}
  }

  message CreateOrderRequest {
    int64 restaurnatId = 1;
    int64 consumerId = 2;
    repeated LineItem lineItems = 3;
    ...
  }
'''
- 장점 : 다양한 업데이트 작업(큰 메시지 교환)이 포함된 API 설계가 쉬움
- 단점 : REST API보다 클라이언트가 하는 일이 많음
### 3.2.3 부분 실패 처리 : 회로 차단기 패턴
- 회로 차단기(circuit breaker) : 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시
- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재함
- 이에 우리는 원격 서비스의 실패 시 어떻게 조치해야 할지 결정해야 함
#### 견고한 RPI 프록시 설계
- 다른 서비스를 동기 호출할 때 자기 스스로를 방어하는 방법
  - 네트워크 타임아웃, 미처리 요청 개수 제한, 회로 차단기 패턴

### 3.2.4 서비스 디스커버리
- REST API 호출 시, 서비스 인스턴스의 네트워크 위치(IP 주소 및 포트)를 알고 있어야 요청 할 수 있음.
- 하지만 요즘 클라우드 기반의 마이크로서비스 app은 네트워크 위치가 꽤나 동적이라 이를 식별하기 어려움. -> 이에 서비스 디스커버리 사용!
#### 서비스 디스커버리 개요
- 핵심은 app 서비스 인스턴스의 네트워크 위치를 DB화하는 서비스 레지스트리
- 서비스 인스턴스가 시작/종료할 때마다 서비스 레지스트리가 업데이트 됨.
- 클라이언트 서비스 호출 => 서비스 디스커버리가 서비스 레지스트리에서 가용 서비스 인스턴스 목록 가져옴 => 그중 한 서비스로 요청 라우팅
#### 애플리케이션 수준의 서비스 디스커버리 패턴 적용
- 총 두가지 패턴이 조합됨.
- 자가등록(self registration) 패턴 : 서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리 등록 API를 호출해서 등록
- 클라이언트 쪽 디스커버리 패턴 : 서비스를 호출할 때 서비스 인스턴스 목록을 요청해서 넘겨받고, 서비스 클라이언트는 라운드-로빈이나 랜덤 같은 부하 분산 알고리즘을 이용하여 서비스 인스턴스를 선택한 후 요청 전송.
#### 플랫폼에 내장된 서비스 디스커버리 패턴 적용
- 마찬가지로 두 패턴 접목
- 서드파티 등록 패턴 : 서비스가아닌 배포 플랫폼의 일부인 등록시(레지스트라)라는 서드파티가 이 작업을 대행
- 서버 쪽 디스커버리 패턴 : 클라이언트가 서비스 디스커버리를 담당한 라우터에 요청

## 3.3 비동기 메시징 패턴 응용 통신

## 3.4 비동기 메시징으로 가용성 개선

## 3.5 마치며
