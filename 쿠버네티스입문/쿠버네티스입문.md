### 쿠버네티스 입문.

### PART I. 쿠버네티스

##### 1. 쿠버네티스 소개

- 컨테이너를 이용하면 개발환경과 운영 환경의 차이 때문에 일어나는 많은 장애를 막을 수 있음.
- 허나 컨테이너만으로 실제 상용 서비스를 운영하기에는 부족한 부분이 있음.
- 서버 하나에 장애가 발생했을 때 그 장애 때문에 상용 서비스에 영향을 받지 않도록 여러 대 서버를 이용해야 함.
- 클러스터 : 여러 대의 서버를 묶어 시스템 하나로 구성하는 방식.
- 쿠버네티스(Kubernetes)는 배의 조타수란 그리스 단어에서 유래.
- 인기를 얻은 이유? 사용하기 간편한 선언적 API, 손쉬운 접근성, 강력한 커뮤니티
- 선언적? 컨테이너가 10개가 실행되게 해줘! => 쿠버네티스가 관리.
- 단일 장애점(Sing Poin Of Failure, SPOF) : 시스템 구성 요소 중 동작하지 않으면 전체 시스템이 중단되는 요소.
- 리버스 프록시 : 클라이언트가 서버를 호출 할 때 리버스 프록시를 호출하게 되고, 프록시 서버가 서버를 요청하여 받은 응답을 클라이언트에게 전달하는 방식.
- CNI : Container Network Interface
- 마스터 노드 : 노드들의 상태를 관리하고 제어
- 워커 노드 : 마스터 노드의 명령을 받아 사용자가 선언한 파드나 잡을 실제 실행.

##### 3. 쿠버네티스로 컨테이너 실행하기

- 쿠버네티스 클러스터를 관리하는 동작 대부분은 kubectl이라는 CLI로 실행가능.

- 파드로 컨테이너 실행, 상태 확인, 컨테이너 삭제

- 쿠버테니스를 이용해서 컨테이너 실행 방법

  - kubectl run 명령으로 직접 컨테이너 실행
  - 컨테이너를 어떻게 실행할지 세부 내용을 담은 YAML 형식의 템플릿으로 컨테이너를 실행
    - kubectl apply -f nginx-app.yaml

- 실행중인 컨테이너에 외부에서 접근하기 => 쿠버네티스의 서비스를 사용해야 함!

- 서비스 타입에는 ClusterIP, NodePort, LoadBalancer, ExternalName이 있음.

- 서비스 하나에 모든 노드의 지정된 포트를 할당하는 NodePort 설정

  - kubectl expose deployment nginx-app --type=NodePort
  - ![image-20220217155054611](/Users/jayo/Library/Application Support/typora-user-images/image-20220217155054611.png)

  - 80:31572 => 쿠버네티스 내부의 80번 포트가 31572라는 외부 포트와 연결되었음!



### Part II. 쿠버네티스 기본 개념

##### 4. 쿠버네티스 아키텍처

- 쿠버네티스 클러스터는 크게 두 종류의 서버로 구성함.

  - 클러스터를 관리하는 마스터와 실제 컨테이너를 실행시키는 노드.

- 마스터

  - etcd, kube-apiserver, kube-scheduler, kube-controller-manager, kublet, kube-proxy, docker
  - 보통 고가용성을 만족하고자 서버 3대 정도 구성해서 운영.
  - 쿠버네티스의 모든 통신은 kube-apiserver가 중심.
  - ![image-20220217161416559](/Users/jayo/Library/Application Support/typora-user-images/image-20220217161416559.png)
  - etcd
    - 코어 OS에서 개발한 고가용성을 제공하는 키-값 저장소
    - 분산 시스템에서 노드 사이의 상태를 공유하는 합의(consensus) 알고리즘 중 하나인 raft 알고리즘을 구현한 것
  - kube-apiserver
    - 쿠버네티스 클러스터의 API를 사용할 수 있도록 하는 컴포넌트. 수평적 확장에 맞게 설계함.
  - kube-scheduler
    - 현재 클러스터 안에서 자원 할당이 가능한 노드 중 알맞은 노드를 선택해서 새롭게 만든 파드를 실행.
  - Kube-controller-manager
    - 컨트롤러 각각을 실행하는 컴포넌트.

  - Cloud-controller-manager
    - 컨트롤러들을 클라우드 서비스와 연결해 관리하는 컴포넌트.

- 쿠버네티스는 크게 오브젝트와 오브젝트를 관리하는 컨트롤러로 나뉨.

- 사용자는 템플릿 등으로 쿠버네티스에 자원의 '바라는 상태(desired state)'를 정의하고 컨트롤러는 바라는 상태와 현재 상태가 일치하도록 오브젝트를 생성/삭제함.

- 오브젝트 - 파드, 서비스, 볼륨, 네임스페이스
- 컨트롤러 - 레플리카세트(ReplicaSet), 디플로이먼트(Deployment), 스테이트풀세트(StatefulSet), 데몬세트(DemonSet), 잡(Job) 등이 있음.

- 네임스페이스 - 클러스터 하나를 여러 개 논리적인 단위로 나눠서 사용하는 것
  - kubectl get namespaces
- 템플릿 - 클러스터의 오브젝트, 컨트롤러의 상태 정의. YAML 형식을 사용
  - apiVersion : 쿠버네티스 API 버전 명시
  - kind : 어떤 종류의 작업인지 명시



##### 5. 파드

- 쿠버네티스는 파드라는 단위로 컨테이너를 묶어서 관리하므로 보통 컨테이너 하나가 아닌 여러 개 컨테이너로 구성됨. 
- ![image-20220217164943718](/Users/jayo/Library/Application Support/typora-user-images/image-20220217164943718.png)

- kubectl get pods

##### 6. 컨트롤러

- 레플리카세트 : 지정된 숫자의 파드들이 계속 동작하도록 보장하는 리소스
- ![image-20220217173159473](/Users/jayo/Library/Application Support/typora-user-images/image-20220217173159473.png)

- 파드는 레이블 기준으로 관리하기에, ReplicaSet과 Pod는 느슨하게 결합되어 있음.
- Deployment : 쿠버네티스에서 상태가 없는(stateless) 앱을 배포할 때 사용하는 가장 기본적인 컨트롤러. 진정한 무중단 시스템을 달성하려고 할 때에 사용하는 리소스

##### 7. 서비스

- 동적으로 변하는 파드들에 고정적으로 접근할 때 사용하는 방법.
- 파드가 클러스터 안 다른 위치로 옮겨 IP가 변하더라도 서비스가 자동으로 새로 위치를 옮겨 실행한 파드와 통신하므로 문제없이 사용 가능.
- 서비스 타입 : ClusterIP, NodePort, LoadBalancer, ExternalName
  - ClusterIP : 쿠버네티스 클러스터 안에서만 사용할 수 있는 IP
  - NodePort : 클러스터 외부에서 클러스터 안 파드로 접근할 때 사용하는 포트

![image-20220217175506413](/Users/jayo/Library/Application Support/typora-user-images/image-20220217175506413.png)

##### 10장. 컨피그맵

- 컨테이너에 필요한 환경 설정을 컨테이너와 분리해서 제공하는 기능
- 개발 시에는 디버그 모드로 로그를 출력하고, 서비스용에서는 시스템 정보를 나타내는 모드로 로그를 출력하는 것과 같이 다른 설정으로 컨테이너를 실행해야 할 때 사용.

##### 11. 시크릿

- 비밀번호, OAuth 토근, SSH 키 같은 민감한 정보들을



배포 -> 쿠버네티스로 한다고 생각하자

리눅스, 도커, 쿠버네티스